import type { TestCase } from '../types';

export type JiraIntegrationResult = Record<string, {
    status: 'success' | 'error';
    issueKey?: string;
    error?: string;
}>;


// This function simulates a network request to the Jira API.
const mockJiraApiCall = (payload: any): Promise<{ id: string, key: string }> => {
    return new Promise((resolve, reject) => {
        // Simulate network latency between 1-2 seconds
        setTimeout(() => {
            console.log("Simulating Jira API call with payload:", payload);
            
            // Simulate a potential random failure
            if (Math.random() < 0.1) { // 10% chance of failure
                reject(new Error("Jira API Error: Invalid JQL query."));
                return;
            }

            const issueKey = `HCQA-${Math.floor(Math.random() * 900) + 100}`;
            resolve({ id: String(Math.floor(Math.random() * 10000)), key: issueKey });
        }, 1000 + Math.random() * 1000);
    });
};

/**
 * Exports a list of test cases to Jira.
 * In a real-world application, this function would handle OAuth 2.0 authentication.
 * @param testCases - The array of test cases to export.
 * @param requirementId - The ID of the source requirement.
 * @returns A promise that resolves to a record of integration results.
 */
export const exportToJira = async (
    testCases: TestCase[],
    requirementId: string
): Promise<JiraIntegrationResult> => {
    
    // In a real application, you would handle OAuth 2.0 token acquisition here.
    // This typically involves redirecting the user or using a refresh token.
    // const authToken = await getJiraOAuthToken();
    // For this simulation, we'll proceed without an actual token.

    const results: JiraIntegrationResult = {};

    // Process each test case export sequentially to simulate a batch job.
    for (const tc of testCases) {
        const description = `
*Auto-generated by AI from requirement: ${requirementId}*

*Compliance References:* ${tc.compliance_reference.join(', ')}

h2. Test Steps
# ${tc.test_steps.join('\n# ')}

h2. Expected Result
${tc.expected_result}
        `;
        
        const payload = {
            fields: {
                project: { key: "HCQA" },
                summary: `${tc.test_case_id}: ${tc.objective}`,
                description: description,
                issuetype: { name: "Test Case" }
            }
        };

        try {
            // This is where the actual fetch call would be made in a real app.
            // const response = await fetch('https://your-jira-instance/rest/api/3/issue', {
            //     method: 'POST',
            //     headers: {
            //         'Authorization': `Bearer ${authToken}`,
            //         'Content-Type': 'application/json'
            //     },
            //     body: JSON.stringify(payload)
            // });
            // if (!response.ok) {
            //     const errorData = await response.json();
            //     throw new Error(errorData.errorMessages.join(' '));
            // }
            // const data = await response.json();
            
            const data = await mockJiraApiCall(payload);
            
            results[tc.test_case_id] = { status: 'success', issueKey: data.key };

        } catch (error) {
            results[tc.test_case_id] = { status: 'error', error: error instanceof Error ? error.message : 'An unknown error occurred' };
        }
    }
    
    return results;
};